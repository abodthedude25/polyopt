// Loop Fusion Candidate
// Two consecutive loops over the same iteration space
// Fusion improves data locality by keeping data in cache
// Demonstrates: when loop fusion is beneficial

func fusion_candidate(A[N], B[N], C[N], D[N]) {
    // Loop 1: B[i] = A[i] * 2
    for i = 0 to N {
        B[i] = A[i] * 2.0;
    }
    
    // Loop 2: C[i] = B[i] + 1 (uses result of Loop 1)
    for i = 0 to N {
        C[i] = B[i] + 1.0;
    }
    
    // Loop 3: D[i] = C[i] * C[i]
    for i = 0 to N {
        D[i] = C[i] * C[i];
    }
}

// After fusion (if legal):
// for i = 0 to N {
//     B[i] = A[i] * 2.0;
//     C[i] = B[i] + 1.0;
//     D[i] = C[i] * C[i];
// }
