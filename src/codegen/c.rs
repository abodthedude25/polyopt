//! C code generation from polyhedral representation.
//!
//! This module implements code generation using a simplified AST scanning approach.

use crate::ir::pir::{
    PolyProgram, PolyStmt, StmtBody, ComputeExpr, AccessExpr, 
    BinaryComputeOp, UnaryComputeOp, CompoundOp, ElementType,
};
use crate::analysis::{Dependence, DependenceAnalysis};
use crate::utils::pretty::CodeFormatter;
use anyhow::Result;

/// Code generation options.
#[derive(Debug, Clone)]
pub struct CodeGenOptions {
    /// Enable OpenMP parallelization
    pub openmp: bool,
    /// Enable vectorization hints
    pub vectorize: bool,
    /// Generate memory allocation code
    pub generate_alloc: bool,
    /// Generate timing code
    pub generate_timing: bool,
    /// Tile sizes (if tiling was applied)
    pub tile_sizes: Vec<i64>,
    /// Generate bounds checking
    pub bounds_check: bool,
    /// Target architecture
    pub arch: Architecture,
}

impl Default for CodeGenOptions {
    fn default() -> Self {
        Self {
            openmp: false,
            vectorize: false,
            generate_alloc: false,
            generate_timing: false,
            tile_sizes: vec![],
            bounds_check: false,
            arch: Architecture::Generic,
        }
    }
}

/// Target architecture for optimization hints.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Architecture {
    /// Generic target
    Generic,
    /// x86-64
    X86_64,
    /// ARM64
    ARM64,
    /// GPU (CUDA/OpenCL)
    GPU,
}

/// C code generator.
pub struct CCodeGen {
    options: CodeGenOptions,
}

impl CCodeGen {
    /// Create a new C code generator with OpenMP flag.
    pub fn new(openmp: bool) -> Self {
        Self {
            options: CodeGenOptions {
                openmp,
                ..Default::default()
            },
        }
    }

    /// Create with full options.
    pub fn with_options(options: CodeGenOptions) -> Self {
        Self { options }
    }

    /// Generate C code for a program.
    pub fn generate(&self, program: &PolyProgram) -> Result<String> {
        let mut f = CodeFormatter::new("    ");

        // Headers
        self.generate_headers(&mut f);

        // Array allocation helper if needed
        if self.options.generate_alloc {
            self.generate_alloc_helpers(&mut f, program);
        }

        // Main function
        self.generate_function(&mut f, program)?;

        // Generate main() wrapper if timing is enabled
        if self.options.generate_timing {
            self.generate_main_wrapper(&mut f, program);
        }

        Ok(f.finish())
    }

    fn generate_headers(&self, f: &mut CodeFormatter) {
        f.writeln("// Generated by PolyOpt - Polyhedral Optimizer");
        f.writeln("");
        f.writeln("#include <stdio.h>");
        f.writeln("#include <stdlib.h>");
        f.writeln("#include <string.h>");
        f.writeln("#include <math.h>");
        
        if self.options.openmp {
            f.writeln("#include <omp.h>");
        }
        
        if self.options.generate_timing {
            f.writeln("#include <time.h>");
            f.writeln("#include <sys/time.h>");
        }
        
        f.writeln("");
        
        // Utility macros
        f.writeln("// Utility macros");
        f.writeln("#define MIN(a, b) ((a) < (b) ? (a) : (b))");
        f.writeln("#define MAX(a, b) ((a) > (b) ? (a) : (b))");
        f.writeln("#define CEIL_DIV(a, b) (((a) + (b) - 1) / (b))");
        f.writeln("#define FLOOR_DIV(a, b) ((a) / (b))");
        f.writeln("");
    }

    fn generate_alloc_helpers(&self, f: &mut CodeFormatter, program: &PolyProgram) {
        f.writeln("// Memory allocation helpers");
        
        for array in &program.arrays {
            let ty = self.type_to_c(&array.element_type);
            let ndim = array.ndims;
            
            if ndim == 1 {
                f.writeln(&format!(
                    "static inline {}* alloc_{}(int n) {{",
                    ty, array.name
                ));
                f.indent();
                f.writeln(&format!(
                    "return ({}*)calloc(n, sizeof({}));",
                    ty, ty
                ));
                f.dedent();
                f.writeln("}");
            } else if ndim == 2 {
                f.writeln(&format!(
                    "static inline {}* alloc_{}(int n, int m) {{",
                    ty, array.name
                ));
                f.indent();
                f.writeln(&format!(
                    "return ({}*)calloc(n * m, sizeof({}));",
                    ty, ty
                ));
                f.dedent();
                f.writeln("}");
            }
        }
        f.writeln("");
    }

    fn generate_function(&self, f: &mut CodeFormatter, program: &PolyProgram) -> Result<()> {
        // Analyze dependencies for parallelism info
        let analyzer = DependenceAnalysis::new();
        let deps = analyzer.analyze(program).unwrap_or_default();
        
        // Function signature
        f.write(&format!("void {}(", program.name));
        
        let mut params = Vec::new();
        
        // Size parameters
        for param in &program.parameters {
            params.push(format!("int {}", param));
        }
        
        // Array parameters
        for array in &program.arrays {
            let ty = self.type_to_c(&array.element_type);
            let restrict_kw = if self.options.openmp { " restrict" } else { "" };
            params.push(format!("{}*{} {}", ty, restrict_kw, array.name));
        }
        
        f.write(&params.join(", "));
        f.writeln(") {");
        f.indent();

        // Generate code using AST scanning
        self.generate_scanned_code(f, program, &deps)?;

        f.dedent();
        f.writeln("}");
        f.writeln("");

        Ok(())
    }

    /// Generate code using simplified AST scanning.
    fn generate_scanned_code(
        &self,
        f: &mut CodeFormatter,
        program: &PolyProgram,
        deps: &[Dependence],
    ) -> Result<()> {
        for (stmt_idx, stmt) in program.statements.iter().enumerate() {
            if stmt_idx > 0 {
                f.writeln("");
            }
            
            // Comment for this statement
            f.writeln(&format!("// Statement S{}: {}", stmt_idx, stmt.name));
            
            // Check if this statement can be parallelized
            let can_parallelize = self.can_parallelize_stmt(stmt, deps, 0);
            
            // Generate loop nest for this statement
            self.generate_loop_nest(f, stmt, program, can_parallelize)?;
        }

        Ok(())
    }

    /// Generate loop nest for a single statement.
    fn generate_loop_nest(
        &self,
        f: &mut CodeFormatter,
        stmt: &PolyStmt,
        program: &PolyProgram,
        parallelize_outer: bool,
    ) -> Result<()> {
        let depth = stmt.depth();
        if depth == 0 {
            // Scalar statement
            self.generate_body(f, &stmt.body)?;
            return Ok(());
        }

        let dim_names = stmt.domain.dim_names();
        let param_names = &program.parameters;

        // Generate nested loops
        for d in 0..depth {
            let var = dim_names.get(d)
                .map(|s| s.as_str())
                .unwrap_or("i");
            
            // OpenMP pragma for outer parallel loop
            if self.options.openmp && d == 0 && parallelize_outer {
                let reduction = self.get_reduction_info(stmt);
                if let Some((op, var_name)) = reduction {
                    f.writeln(&format!("#pragma omp parallel for reduction({}:{})", op, var_name));
                } else {
                    f.writeln("#pragma omp parallel for");
                }
            }
            
            // Vectorization hint for innermost loop
            if self.options.vectorize && d == depth - 1 {
                f.writeln("#pragma omp simd");
            }
            
            // Get bounds - use parameter or default
            let upper = param_names.get(d).cloned().unwrap_or_else(|| "N".to_string());
            
            f.writeln(&format!(
                "for (int {} = 0; {} < {}; {}++) {{",
                var, var, upper, var
            ));
            f.indent();
        }

        // Generate statement body
        self.generate_body(f, &stmt.body)?;

        // Close loops
        for _ in 0..depth {
            f.dedent();
            f.writeln("}");
        }

        Ok(())
    }

    /// Check if a statement can be parallelized at a given loop level.
    fn can_parallelize_stmt(&self, stmt: &PolyStmt, deps: &[Dependence], level: usize) -> bool {
        for dep in deps {
            if dep.source.0 == stmt.id.0 || dep.target.0 == stmt.id.0 {
                if let Some(ref distance) = dep.distance {
                    if let Some(&d) = distance.get(level) {
                        if d != 0 {
                            return false;
                        }
                    }
                }
                if let Some(dir) = dep.direction.get(level) {
                    use crate::analysis::Direction;
                    match dir {
                        Direction::Lt | Direction::Le | Direction::Gt | Direction::Ge => {
                            return false;
                        }
                        _ => {}
                    }
                }
            }
        }
        true
    }

    /// Get reduction information if the statement performs a reduction.
    fn get_reduction_info(&self, stmt: &PolyStmt) -> Option<(String, String)> {
        match &stmt.body {
            StmtBody::CompoundAssign { target, op, .. } => {
                let op_str = match op {
                    CompoundOp::Add => "+",
                    CompoundOp::Mul => "*",
                    _ => return None,
                };
                Some((op_str.to_string(), target.array.clone()))
            }
            _ => None,
        }
    }

    fn generate_body(&self, f: &mut CodeFormatter, body: &StmtBody) -> Result<()> {
        match body {
            StmtBody::Assignment { target, expr } => {
                let target_str = self.generate_access(target);
                let expr_str = self.generate_expr(expr);
                f.writeln(&format!("{} = {};", target_str, expr_str));
            }
            StmtBody::CompoundAssign { target, op, expr } => {
                let target_str = self.generate_access(target);
                let expr_str = self.generate_expr(expr);
                let op_str = match op {
                    CompoundOp::Add => "+=",
                    CompoundOp::Sub => "-=",
                    CompoundOp::Mul => "*=",
                    CompoundOp::Div => "/=",
                };
                f.writeln(&format!("{} {} {};", target_str, op_str, expr_str));
            }
        }
        Ok(())
    }

    fn generate_access(&self, access: &AccessExpr) -> String {
        if access.indices.is_empty() {
            access.array.clone()
        } else {
            let indices: Vec<String> = access.indices.iter()
                .map(|i| format!("[{}]", i.0))
                .collect();
            format!("{}{}", access.array, indices.join(""))
        }
    }

    fn generate_expr(&self, expr: &ComputeExpr) -> String {
        match expr {
            ComputeExpr::Int(v) => v.to_string(),
            ComputeExpr::Float(v) => {
                if v.fract() == 0.0 {
                    format!("{:.1}", v)
                } else {
                    format!("{}", v)
                }
            }
            ComputeExpr::Var(name) => name.clone(),
            ComputeExpr::Access(acc) => self.generate_access(acc),
            ComputeExpr::Binary { op, left, right } => {
                let l = self.generate_expr(left);
                let r = self.generate_expr(right);
                let op_str = match op {
                    BinaryComputeOp::Add => "+",
                    BinaryComputeOp::Sub => "-",
                    BinaryComputeOp::Mul => "*",
                    BinaryComputeOp::Div => "/",
                    BinaryComputeOp::Mod => "%",
                };
                format!("({} {} {})", l, op_str, r)
            }
            ComputeExpr::Unary { op, operand } => {
                let o = self.generate_expr(operand);
                match op {
                    UnaryComputeOp::Neg => format!("(-{})", o),
                }
            }
            ComputeExpr::Call { func, args } => {
                let args_str: Vec<String> = args.iter()
                    .map(|a| self.generate_expr(a))
                    .collect();
                format!("{}({})", func, args_str.join(", "))
            }
        }
    }

    fn type_to_c(&self, ty: &ElementType) -> &'static str {
        match ty {
            ElementType::Int => "int",
            ElementType::Float => "float",
            ElementType::Double => "double",
        }
    }

    fn generate_main_wrapper(&self, f: &mut CodeFormatter, program: &PolyProgram) {
        f.writeln("// Benchmark wrapper");
        f.writeln("int main(int argc, char** argv) {");
        f.indent();
        
        f.writeln("int N = 1000;");
        f.writeln("if (argc > 1) N = atoi(argv[1]);");
        f.writeln("");
        
        // Allocate arrays
        for array in &program.arrays {
            let ty = self.type_to_c(&array.element_type);
            let size = match array.ndims {
                1 => "N".to_string(),
                2 => "N * N".to_string(),
                3 => "N * N * N".to_string(),
                _ => "N".to_string(),
            };
            f.writeln(&format!(
                "{}* {} = ({}*)calloc({}, sizeof({}));",
                ty, array.name, ty, size, ty
            ));
        }
        f.writeln("");
        
        // Initialize
        f.writeln("// Initialize");
        f.writeln("srand(42);");
        for array in &program.arrays {
            let size = match array.ndims {
                1 => "N".to_string(),
                2 => "N * N".to_string(),
                _ => "N".to_string(),
            };
            f.writeln(&format!(
                "for (int _i = 0; _i < {}; _i++) {}[_i] = (double)rand() / RAND_MAX;",
                size, array.name
            ));
        }
        f.writeln("");
        
        // Timing
        f.writeln("// Timing");
        f.writeln("struct timeval start, end;");
        f.writeln("gettimeofday(&start, NULL);");
        f.writeln("");
        
        // Call function
        let mut args: Vec<String> = program.parameters.iter()
            .map(|_| "N".to_string())
            .collect();
        args.extend(program.arrays.iter().map(|a| a.name.clone()));
        f.writeln(&format!("{}({});", program.name, args.join(", ")));
        f.writeln("");
        
        // End timing
        f.writeln("gettimeofday(&end, NULL);");
        f.writeln("double elapsed = (end.tv_sec - start.tv_sec) + ");
        f.writeln("                 (end.tv_usec - start.tv_usec) / 1e6;");
        f.writeln(r#"printf("Time: %.4f seconds\n", elapsed);"#);
        f.writeln("");
        
        // Cleanup
        for array in &program.arrays {
            f.writeln(&format!("free({});", array.name));
        }
        f.writeln("return 0;");
        
        f.dedent();
        f.writeln("}");
    }
}

/// Generate tiled code for a program.
pub fn generate_tiled_code(
    program: &PolyProgram,
    tile_sizes: &[i64],
    openmp: bool,
) -> Result<String> {
    let options = CodeGenOptions {
        openmp,
        tile_sizes: tile_sizes.to_vec(),
        ..Default::default()
    };
    let codegen = CCodeGen::with_options(options);
    codegen.generate(program)
}

/// Generate optimized code with timing instrumentation.
pub fn generate_benchmark(program: &PolyProgram, openmp: bool) -> Result<String> {
    let options = CodeGenOptions {
        openmp,
        generate_timing: true,
        generate_alloc: true,
        ..Default::default()
    };
    let codegen = CCodeGen::with_options(options);
    codegen.generate(program)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::pir::*;
    use crate::polyhedral::{IntegerSet, AffineMap};

    #[test]
    fn test_codegen_new() {
        let cg = CCodeGen::new(false);
        assert!(!cg.options.openmp);
        
        let cg = CCodeGen::new(true);
        assert!(cg.options.openmp);
    }

    #[test]
    fn test_codegen_options() {
        let options = CodeGenOptions {
            openmp: true,
            vectorize: true,
            generate_timing: true,
            ..Default::default()
        };
        let cg = CCodeGen::with_options(options);
        assert!(cg.options.openmp);
        assert!(cg.options.vectorize);
    }

    #[test]
    fn test_generate_simple() {
        let mut program = PolyProgram::new("test".to_string());
        program.parameters = vec!["N".to_string()];
        program.arrays.push(ArrayInfo {
            name: "A".to_string(),
            element_type: ElementType::Double,
            ndims: 1,
            sizes: vec!["N".to_string()],
        });

        let domain = IntegerSet::rectangular(&[10]);
        let schedule = AffineMap::identity(1);
        
        let stmt = PolyStmt {
            id: StmtId::new(0),
            name: "S0".to_string(),
            domain,
            schedule,
            reads: vec![],
            writes: vec![AccessRelation {
                array: "A".to_string(),
                relation: AffineMap::identity(1),
                kind: AccessKind::Write,
            }],
            body: StmtBody::Assignment {
                target: AccessExpr {
                    array: "A".to_string(),
                    indices: vec![AffineExprStr("i".to_string())],
                },
                expr: ComputeExpr::Int(0),
            },
            span: crate::utils::location::Span::default(),
        };
        program.statements.push(stmt);

        let cg = CCodeGen::new(false);
        let code = cg.generate(&program).unwrap();
        
        assert!(code.contains("void test("));
        assert!(code.contains("for (int"));
    }

    #[test]
    fn test_generate_openmp() {
        let mut program = PolyProgram::new("test".to_string());
        program.parameters = vec!["N".to_string()];
        program.arrays.push(ArrayInfo {
            name: "A".to_string(),
            element_type: ElementType::Double,
            ndims: 1,
            sizes: vec!["N".to_string()],
        });

        let domain = IntegerSet::rectangular(&[10]);
        let schedule = AffineMap::identity(1);
        
        let stmt = PolyStmt {
            id: StmtId::new(0),
            name: "S0".to_string(),
            domain,
            schedule,
            reads: vec![],
            writes: vec![],
            body: StmtBody::Assignment {
                target: AccessExpr {
                    array: "A".to_string(),
                    indices: vec![AffineExprStr("i".to_string())],
                },
                expr: ComputeExpr::Int(0),
            },
            span: crate::utils::location::Span::default(),
        };
        program.statements.push(stmt);

        let cg = CCodeGen::new(true);
        let code = cg.generate(&program).unwrap();
        
        assert!(code.contains("#include <omp.h>"));
        assert!(code.contains("#pragma omp parallel for"));
    }

    #[test]
    fn test_generate_benchmark() {
        let mut program = PolyProgram::new("kernel".to_string());
        program.parameters = vec!["N".to_string()];
        program.arrays.push(ArrayInfo {
            name: "A".to_string(),
            element_type: ElementType::Double,
            ndims: 1,
            sizes: vec!["N".to_string()],
        });

        let code = generate_benchmark(&program, false).unwrap();
        assert!(code.contains("int main("));
        assert!(code.contains("gettimeofday"));
    }
}
